<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  ProfileService\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ProfileService-TEST
 *
 * Profile service
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.62
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ProfileService\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ProfileService\Client\ApiException;
use ProfileService\Client\Configuration;
use ProfileService\Client\HeaderSelector;
use ProfileService\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  ProfileService\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation acceptATermVersion
     *
     * Accept a term-version
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body TermVersionCheckRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTermVersionCheckResponse
     */
    public function acceptATermVersion($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        list($response) = $this->acceptATermVersionWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);
        return $response;
    }

    /**
     * Operation acceptATermVersionWithHttpInfo
     *
     * Accept a term-version
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body TermVersionCheckRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTermVersionCheckResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function acceptATermVersionWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTermVersionCheckResponse';
        $request = $this->acceptATermVersionRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTermVersionCheckResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation acceptATermVersionAsync
     *
     * Accept a term-version
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body TermVersionCheckRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptATermVersionAsync($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        return $this->acceptATermVersionAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acceptATermVersionAsyncWithHttpInfo
     *
     * Accept a term-version
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body TermVersionCheckRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptATermVersionAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTermVersionCheckResponse';
        $request = $this->acceptATermVersionRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acceptATermVersion'
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body TermVersionCheckRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function acceptATermVersionRequest($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {

        $resourcePath = '/terms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addGuestCardToUser
     *
     * Add guest card to user
     *
     * @param  \ProfileService\Client\Model\DsGuestCardRequest $body Deposite Guest Card request model. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTicketResponse
     */
    public function addGuestCardToUser($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null)
    {
        list($response) = $this->addGuestCardToUserWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language);
        return $response;
    }

    /**
     * Operation addGuestCardToUserWithHttpInfo
     *
     * Add guest card to user
     *
     * @param  \ProfileService\Client\Model\DsGuestCardRequest $body Deposite Guest Card request model. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTicketResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGuestCardToUserWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketResponse';
        $request = $this->addGuestCardToUserRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTicketResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsValidationResultArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addGuestCardToUserAsync
     *
     * Add guest card to user
     *
     * @param  \ProfileService\Client\Model\DsGuestCardRequest $body Deposite Guest Card request model. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGuestCardToUserAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null)
    {
        return $this->addGuestCardToUserAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGuestCardToUserAsyncWithHttpInfo
     *
     * Add guest card to user
     *
     * @param  \ProfileService\Client\Model\DsGuestCardRequest $body Deposite Guest Card request model. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGuestCardToUserAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketResponse';
        $request = $this->addGuestCardToUserRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGuestCardToUser'
     *
     * @param  \ProfileService\Client\Model\DsGuestCardRequest $body Deposite Guest Card request model. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addGuestCardToUserRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null)
    {

        $resourcePath = '/tickets/guestcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelDeletionProfile
     *
     * Cancel deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelDeletionProfile($authorization, $ocp_apim_subscription_key = null)
    {
        $this->cancelDeletionProfileWithHttpInfo($authorization, $ocp_apim_subscription_key);
    }

    /**
     * Operation cancelDeletionProfileWithHttpInfo
     *
     * Cancel deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelDeletionProfileWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->cancelDeletionProfileRequest($authorization, $ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelDeletionProfileAsync
     *
     * Cancel deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDeletionProfileAsync($authorization, $ocp_apim_subscription_key = null)
    {
        return $this->cancelDeletionProfileAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelDeletionProfileAsyncWithHttpInfo
     *
     * Cancel deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDeletionProfileAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->cancelDeletionProfileRequest($authorization, $ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelDeletionProfile'
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelDeletionProfileRequest($authorization, $ocp_apim_subscription_key = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling cancelDeletionProfile'
            );
        }

        $resourcePath = '/me/cancelDelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkAcceptedTerm
     *
     * Check accepted term
     *
     * @param  string $code The code of the term to test if it has been accepted already. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTermVersionCheckResponse
     */
    public function checkAcceptedTerm($code, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        list($response) = $this->checkAcceptedTermWithHttpInfo($code, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);
        return $response;
    }

    /**
     * Operation checkAcceptedTermWithHttpInfo
     *
     * Check accepted term
     *
     * @param  string $code The code of the term to test if it has been accepted already. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTermVersionCheckResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkAcceptedTermWithHttpInfo($code, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTermVersionCheckResponse';
        $request = $this->checkAcceptedTermRequest($code, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTermVersionCheckResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkAcceptedTermAsync
     *
     * Check accepted term
     *
     * @param  string $code The code of the term to test if it has been accepted already. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkAcceptedTermAsync($code, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        return $this->checkAcceptedTermAsyncWithHttpInfo($code, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkAcceptedTermAsyncWithHttpInfo
     *
     * Check accepted term
     *
     * @param  string $code The code of the term to test if it has been accepted already. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkAcceptedTermAsyncWithHttpInfo($code, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTermVersionCheckResponse';
        $request = $this->checkAcceptedTermRequest($code, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkAcceptedTerm'
     *
     * @param  string $code The code of the term to test if it has been accepted already. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkAcceptedTermRequest($code, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling checkAcceptedTerm'
            );
        }

        $resourcePath = '/terms/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmDeletionProfile
     *
     * Confirm deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function confirmDeletionProfile($authorization, $ocp_apim_subscription_key = null)
    {
        $this->confirmDeletionProfileWithHttpInfo($authorization, $ocp_apim_subscription_key);
    }

    /**
     * Operation confirmDeletionProfileWithHttpInfo
     *
     * Confirm deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function confirmDeletionProfileWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->confirmDeletionProfileRequest($authorization, $ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation confirmDeletionProfileAsync
     *
     * Confirm deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmDeletionProfileAsync($authorization, $ocp_apim_subscription_key = null)
    {
        return $this->confirmDeletionProfileAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmDeletionProfileAsyncWithHttpInfo
     *
     * Confirm deletion profile
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmDeletionProfileAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->confirmDeletionProfileRequest($authorization, $ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmDeletionProfile'
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function confirmDeletionProfileRequest($authorization, $ocp_apim_subscription_key = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling confirmDeletionProfile'
            );
        }

        $resourcePath = '/me/confirmDelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmStay
     *
     * Confirm stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponse
     */
    public function confirmStay($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->confirmStayWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation confirmStayWithHttpInfo
     *
     * Confirm stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function confirmStayWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->confirmStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation confirmStayAsync
     *
     * Confirm stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmStayAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->confirmStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmStayAsyncWithHttpInfo
     *
     * Confirm stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->confirmStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmStay'
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function confirmStayRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling confirmStay'
            );
        }

        $resourcePath = '/stays/{id}/confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCard
     *
     * Create card
     *
     * @param  \ProfileService\Client\Model\DsCardRequest $body Card request model (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsCardResponse
     */
    public function createCard($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->createCardWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation createCardWithHttpInfo
     *
     * Create card
     *
     * @param  \ProfileService\Client\Model\DsCardRequest $body Card request model (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsCardResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCardWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->createCardRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsCardResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCardAsync
     *
     * Create card
     *
     * @param  \ProfileService\Client\Model\DsCardRequest $body Card request model (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCardAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->createCardAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCardAsyncWithHttpInfo
     *
     * Create card
     *
     * @param  \ProfileService\Client\Model\DsCardRequest $body Card request model (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCardAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->createCardRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCard'
     *
     * @param  \ProfileService\Client\Model\DsCardRequest $body Card request model (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCardRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/cards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPartnerdata
     *
     * Create partnerdata
     *
     * @param  \ProfileService\Client\Model\DsPartnerDataCreateRequest $body PartnerDataRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnerDataResponse
     */
    public function createPartnerdata($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->createPartnerdataWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation createPartnerdataWithHttpInfo
     *
     * Create partnerdata
     *
     * @param  \ProfileService\Client\Model\DsPartnerDataCreateRequest $body PartnerDataRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnerDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPartnerdataWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->createPartnerdataRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnerDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPartnerdataAsync
     *
     * Create partnerdata
     *
     * @param  \ProfileService\Client\Model\DsPartnerDataCreateRequest $body PartnerDataRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartnerdataAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->createPartnerdataAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPartnerdataAsyncWithHttpInfo
     *
     * Create partnerdata
     *
     * @param  \ProfileService\Client\Model\DsPartnerDataCreateRequest $body PartnerDataRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartnerdataAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->createPartnerdataRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPartnerdata'
     *
     * @param  \ProfileService\Client\Model\DsPartnerDataCreateRequest $body PartnerDataRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPartnerdataRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/partnerdata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createParty
     *
     * Create party
     *
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest - group of travelers. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartyResponse
     */
    public function createParty($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->createPartyWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation createPartyWithHttpInfo
     *
     * Create party
     *
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest - group of travelers. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPartyWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->createPartyRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPartyAsync
     *
     * Create party
     *
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest - group of travelers. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartyAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->createPartyAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPartyAsyncWithHttpInfo
     *
     * Create party
     *
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest - group of travelers. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartyAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->createPartyRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createParty'
     *
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest - group of travelers. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPartyRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/parties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPartyInvitation
     *
     * Create party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $body body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartyInvitationResponse
     */
    public function createPartyInvitation($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->createPartyInvitationWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation createPartyInvitationWithHttpInfo
     *
     * Create party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartyInvitationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPartyInvitationWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyInvitationResponse';
        $request = $this->createPartyInvitationRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartyInvitationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPartyInvitationAsync
     *
     * Create party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartyInvitationAsync($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->createPartyInvitationAsyncWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPartyInvitationAsyncWithHttpInfo
     *
     * Create party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPartyInvitationAsyncWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyInvitationResponse';
        $request = $this->createPartyInvitationRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPartyInvitation'
     *
     * @param  string $id Id of the party. (required)
     * @param  string $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPartyInvitationRequest($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createPartyInvitation'
            );
        }

        $resourcePath = '/parties/{id}/invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCard
     *
     * Delete card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsCardsIdDelete200ApplicationJsonResponse
     */
    public function deleteCard($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->deleteCardWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation deleteCardWithHttpInfo
     *
     * Delete card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsCardsIdDelete200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCardWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardsIdDelete200ApplicationJsonResponse';
        $request = $this->deleteCardRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsCardsIdDelete200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCardAsync
     *
     * Delete card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCardAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deleteCardAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCardAsyncWithHttpInfo
     *
     * Delete card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCardAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardsIdDelete200ApplicationJsonResponse';
        $request = $this->deleteCardRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCard'
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCardRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCard'
            );
        }

        $resourcePath = '/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMedia
     *
     * Delete media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMedia($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $this->deleteMediaWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);
    }

    /**
     * Operation deleteMediaWithHttpInfo
     *
     * Delete media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMediaWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deleteMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMediaAsync
     *
     * Delete media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMediaAsync($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deleteMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMediaAsyncWithHttpInfo
     *
     * Delete media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deleteMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMedia'
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMediaRequest($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling deleteMedia'
            );
        }

        $resourcePath = '/media/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMyProfile
     *
     * Delete my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMyProfile($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $this->deleteMyProfileWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
    }

    /**
     * Operation deleteMyProfileWithHttpInfo
     *
     * Delete my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMyProfileWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '';
        $request = $this->deleteMyProfileRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMyProfileAsync
     *
     * Delete my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMyProfileAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->deleteMyProfileAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMyProfileAsyncWithHttpInfo
     *
     * Delete my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMyProfileAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '';
        $request = $this->deleteMyProfileRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMyProfile'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMyProfileRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePartnerdata
     *
     * Delete partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnerdataNameDelete200ApplicationJsonResponse
     */
    public function deletePartnerdata($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->deletePartnerdataWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation deletePartnerdataWithHttpInfo
     *
     * Delete partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnerdataNameDelete200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartnerdataWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerdataNameDelete200ApplicationJsonResponse';
        $request = $this->deletePartnerdataRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnerdataNameDelete200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePartnerdataAsync
     *
     * Delete partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartnerdataAsync($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deletePartnerdataAsyncWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePartnerdataAsyncWithHttpInfo
     *
     * Delete partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartnerdataAsyncWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerdataNameDelete200ApplicationJsonResponse';
        $request = $this->deletePartnerdataRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePartnerdata'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePartnerdataRequest($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePartnerdata'
            );
        }

        $resourcePath = '/partnerdata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePartnerdataSharePermission
     *
     * Delete partnerdata share permission
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePartnerdataSharePermission($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $this->deletePartnerdataSharePermissionWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token);
    }

    /**
     * Operation deletePartnerdataSharePermissionWithHttpInfo
     *
     * Delete partnerdata share permission
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartnerdataSharePermissionWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deletePartnerdataSharePermissionRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePartnerdataSharePermissionAsync
     *
     * Delete partnerdata share permission
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartnerdataSharePermissionAsync($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deletePartnerdataSharePermissionAsyncWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePartnerdataSharePermissionAsyncWithHttpInfo
     *
     * Delete partnerdata share permission
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartnerdataSharePermissionAsyncWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deletePartnerdataSharePermissionRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePartnerdataSharePermission'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePartnerdataSharePermissionRequest($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePartnerdataSharePermission'
            );
        }

        $resourcePath = '/partnerdata/{name}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteParty
     *
     * Delete party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartiesIdDelete200ApplicationJsonResponse
     */
    public function deleteParty($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->deletePartyWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation deletePartyWithHttpInfo
     *
     * Delete party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartiesIdDelete200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartyWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesIdDelete200ApplicationJsonResponse';
        $request = $this->deletePartyRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartiesIdDelete200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePartyAsync
     *
     * Delete party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartyAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deletePartyAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePartyAsyncWithHttpInfo
     *
     * Delete party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartyAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesIdDelete200ApplicationJsonResponse';
        $request = $this->deletePartyRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteParty'
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePartyRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteParty'
            );
        }

        $resourcePath = '/parties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePartyInvitation
     *
     * Delete party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartiesIdInviteDelete200ApplicationJsonResponse
     */
    public function deletePartyInvitation($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->deletePartyInvitationWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation deletePartyInvitationWithHttpInfo
     *
     * Delete party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartiesIdInviteDelete200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartyInvitationWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesIdInviteDelete200ApplicationJsonResponse';
        $request = $this->deletePartyInvitationRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartiesIdInviteDelete200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePartyInvitationAsync
     *
     * Delete party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartyInvitationAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deletePartyInvitationAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePartyInvitationAsyncWithHttpInfo
     *
     * Delete party invitation
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartyInvitationAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesIdInviteDelete200ApplicationJsonResponse';
        $request = $this->deletePartyInvitationRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePartyInvitation'
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePartyInvitationRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deletePartyInvitation'
            );
        }

        $resourcePath = '/parties/{id}/invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProfilePicture
     *
     * Delete profile picture
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProfilePicture($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $this->deleteProfilePictureWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token);
    }

    /**
     * Operation deleteProfilePictureWithHttpInfo
     *
     * Delete profile picture
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProfilePictureWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deleteProfilePictureRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProfilePictureAsync
     *
     * Delete profile picture
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilePictureAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deleteProfilePictureAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProfilePictureAsyncWithHttpInfo
     *
     * Delete profile picture
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfilePictureAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '';
        $request = $this->deleteProfilePictureRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProfilePicture'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProfilePictureRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/me/profileimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStay
     *
     * Delete stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStaysIdDelete200ApplicationJsonResponse
     */
    public function deleteStay($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->deleteStayWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation deleteStayWithHttpInfo
     *
     * Delete stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStaysIdDelete200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStayWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStaysIdDelete200ApplicationJsonResponse';
        $request = $this->deleteStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStaysIdDelete200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStayAsync
     *
     * Delete stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStayAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->deleteStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStayAsyncWithHttpInfo
     *
     * Delete stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStaysIdDelete200ApplicationJsonResponse';
        $request = $this->deleteStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStay'
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStayRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteStay'
            );
        }

        $resourcePath = '/stays/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadMedia
     *
     * Download media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsMediaIdentifierDownloadGet200ApplicationOctetStreamResponse
     */
    public function downloadMedia($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->downloadMediaWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation downloadMediaWithHttpInfo
     *
     * Download media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsMediaIdentifierDownloadGet200ApplicationOctetStreamResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadMediaWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierDownloadGet200ApplicationOctetStreamResponse';
        $request = $this->downloadMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsMediaIdentifierDownloadGet200ApplicationOctetStreamResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadMediaAsync
     *
     * Download media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadMediaAsync($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->downloadMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadMediaAsyncWithHttpInfo
     *
     * Download media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierDownloadGet200ApplicationOctetStreamResponse';
        $request = $this->downloadMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadMedia'
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadMediaRequest($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling downloadMedia'
            );
        }

        $resourcePath = '/media/{identifier}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadOrderinfo
     *
     * Download orderinfo
     *
     * @param  string $order_token the token of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsOrderDownload
     */
    public function downloadOrderinfo($order_token, $ocp_apim_subscription_key = null, $accept_timezone = null)
    {
        list($response) = $this->downloadOrderinfoWithHttpInfo($order_token, $ocp_apim_subscription_key, $accept_timezone);
        return $response;
    }

    /**
     * Operation downloadOrderinfoWithHttpInfo
     *
     * Download orderinfo
     *
     * @param  string $order_token the token of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsOrderDownload, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadOrderinfoWithHttpInfo($order_token, $ocp_apim_subscription_key = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrderDownload';
        $request = $this->downloadOrderinfoRequest($order_token, $ocp_apim_subscription_key, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsOrderDownload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadOrderinfoAsync
     *
     * Download orderinfo
     *
     * @param  string $order_token the token of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadOrderinfoAsync($order_token, $ocp_apim_subscription_key = null, $accept_timezone = null)
    {
        return $this->downloadOrderinfoAsyncWithHttpInfo($order_token, $ocp_apim_subscription_key, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadOrderinfoAsyncWithHttpInfo
     *
     * Download orderinfo
     *
     * @param  string $order_token the token of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadOrderinfoAsyncWithHttpInfo($order_token, $ocp_apim_subscription_key = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrderDownload';
        $request = $this->downloadOrderinfoRequest($order_token, $ocp_apim_subscription_key, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadOrderinfo'
     *
     * @param  string $order_token the token of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadOrderinfoRequest($order_token, $ocp_apim_subscription_key = null, $accept_timezone = null)
    {
        // verify the required parameter 'order_token' is set
        if ($order_token === null || (is_array($order_token) && count($order_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_token when calling downloadOrderinfo'
            );
        }

        $resourcePath = '/orderinfos/{orderToken}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($order_token !== null) {
            $resourcePath = str_replace(
                '{' . 'orderToken' . '}',
                ObjectSerializer::toPathValue($order_token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadTicket
     *
     * Download ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTicketsIdDownloadGet200ApplicationOctetStreamResponse
     */
    public function downloadTicket($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->downloadTicketWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation downloadTicketWithHttpInfo
     *
     * Download ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTicketsIdDownloadGet200ApplicationOctetStreamResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadTicketWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsIdDownloadGet200ApplicationOctetStreamResponse';
        $request = $this->downloadTicketRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTicketsIdDownloadGet200ApplicationOctetStreamResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadTicketAsync
     *
     * Download ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadTicketAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->downloadTicketAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadTicketAsyncWithHttpInfo
     *
     * Download ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadTicketAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsIdDownloadGet200ApplicationOctetStreamResponse';
        $request = $this->downloadTicketRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadTicket'
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadTicketRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling downloadTicket'
            );
        }

        $resourcePath = '/tickets/{id}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAddressById
     *
     * GetAddressById
     *
     * @param  string $id Id of the address. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsAddressResponse
     */
    public function getAddressById($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getAddressByIdWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getAddressByIdWithHttpInfo
     *
     * GetAddressById
     *
     * @param  string $id Id of the address. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsAddressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAddressByIdWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsAddressResponse';
        $request = $this->getAddressByIdRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAddressByIdAsync
     *
     * GetAddressById
     *
     * @param  string $id Id of the address. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddressByIdAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getAddressByIdAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAddressByIdAsyncWithHttpInfo
     *
     * GetAddressById
     *
     * @param  string $id Id of the address. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddressByIdAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsAddressResponse';
        $request = $this->getAddressByIdRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAddressById'
     *
     * @param  string $id Id of the address. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAddressByIdRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAddressById'
            );
        }

        $resourcePath = '/addresses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessTrailEntries
     *
     * Get business trail entries
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsBusinessTrailEntryResponse
     */
    public function getBusinessTrailEntries($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        list($response) = $this->getBusinessTrailEntriesWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);
        return $response;
    }

    /**
     * Operation getBusinessTrailEntriesWithHttpInfo
     *
     * Get business trail entries
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsBusinessTrailEntryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessTrailEntriesWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsBusinessTrailEntryResponse';
        $request = $this->getBusinessTrailEntriesRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsBusinessTrailEntryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBusinessTrailEntriesAsync
     *
     * Get business trail entries
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessTrailEntriesAsync($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        return $this->getBusinessTrailEntriesAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessTrailEntriesAsyncWithHttpInfo
     *
     * Get business trail entries
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessTrailEntriesAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsBusinessTrailEntryResponse';
        $request = $this->getBusinessTrailEntriesRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessTrailEntries'
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBusinessTrailEntriesRequest($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {

        $resourcePath = '/businesstrail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCard
     *
     * Get card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsCardResponse
     */
    public function getCard($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getCardWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getCardWithHttpInfo
     *
     * Get card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsCardResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCardWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->getCardRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsCardResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCardAsync
     *
     * Get card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCardAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getCardAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCardAsyncWithHttpInfo
     *
     * Get card
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCardAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->getCardRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCard'
     *
     * @param  string $id Id of the card. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCardRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCard'
            );
        }

        $resourcePath = '/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMedia
     *
     * Get media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsProfileMediaBaseResponse
     */
    public function getMedia($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getMediaWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getMediaWithHttpInfo
     *
     * Get media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsProfileMediaBaseResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMediaWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->getMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsProfileMediaBaseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMediaAsync
     *
     * Get media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaAsync($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMediaAsyncWithHttpInfo
     *
     * Get media
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->getMediaRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMedia'
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMediaRequest($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getMedia'
            );
        }

        $resourcePath = '/media/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMediaBinary
     *
     * Get media binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsMediaIdentifierBase64Get200TextPlainResponse
     */
    public function getMediaBinary($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getMediaBinaryWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getMediaBinaryWithHttpInfo
     *
     * Get media binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsMediaIdentifierBase64Get200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMediaBinaryWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierBase64Get200TextPlainResponse';
        $request = $this->getMediaBinaryRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsMediaIdentifierBase64Get200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMediaBinaryAsync
     *
     * Get media binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaBinaryAsync($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getMediaBinaryAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMediaBinaryAsyncWithHttpInfo
     *
     * Get media binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaBinaryAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierBase64Get200TextPlainResponse';
        $request = $this->getMediaBinaryRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMediaBinary'
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMediaBinaryRequest($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getMediaBinary'
            );
        }

        $resourcePath = '/media/{identifier}/base64';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMediaThumbnailBinary
     *
     * Get media thumbnail binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsMediaIdentifierThumbnailGet200TextPlainResponse
     */
    public function getMediaThumbnailBinary($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getMediaThumbnailBinaryWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getMediaThumbnailBinaryWithHttpInfo
     *
     * Get media thumbnail binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsMediaIdentifierThumbnailGet200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMediaThumbnailBinaryWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierThumbnailGet200TextPlainResponse';
        $request = $this->getMediaThumbnailBinaryRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsMediaIdentifierThumbnailGet200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMediaThumbnailBinaryAsync
     *
     * Get media thumbnail binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaThumbnailBinaryAsync($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getMediaThumbnailBinaryAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMediaThumbnailBinaryAsyncWithHttpInfo
     *
     * Get media thumbnail binary
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaThumbnailBinaryAsyncWithHttpInfo($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMediaIdentifierThumbnailGet200TextPlainResponse';
        $request = $this->getMediaThumbnailBinaryRequest($identifier, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMediaThumbnailBinary'
     *
     * @param  string $identifier Identifier of the media. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMediaThumbnailBinaryRequest($identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getMediaThumbnailBinary'
            );
        }

        $resourcePath = '/media/{identifier}/thumbnail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyCards
     *
     * Get my cards
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsCardResponseArray
     */
    public function getMyCards($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyCardsWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyCardsWithHttpInfo
     *
     * Get my cards
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsCardResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyCardsWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponseArray';
        $request = $this->getMyCardsRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsCardResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyCardsAsync
     *
     * Get my cards
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyCardsAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyCardsAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyCardsAsyncWithHttpInfo
     *
     * Get my cards
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyCardsAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponseArray';
        $request = $this->getMyCardsRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyCards'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyCardsRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/cards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyMedia
     *
     * Get my media
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsProfileMediaBaseResponse
     */
    public function getMyMedia($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getMyMediaWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getMyMediaWithHttpInfo
     *
     * Get my media
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsProfileMediaBaseResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyMediaWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->getMyMediaRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsProfileMediaBaseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyMediaAsync
     *
     * Get my media
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyMediaAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getMyMediaAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyMediaAsyncWithHttpInfo
     *
     * Get my media
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyMediaAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->getMyMediaRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyMedia'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyMediaRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyOrders
     *
     * Get my orders
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsOrdersResponse
     */
    public function getMyOrders($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyOrdersWithHttpInfo($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyOrdersWithHttpInfo
     *
     * Get my orders
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsOrdersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyOrdersWithHttpInfo($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrdersResponse';
        $request = $this->getMyOrdersRequest($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyOrdersAsync
     *
     * Get my orders
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyOrdersAsync($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyOrdersAsyncWithHttpInfo($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyOrdersAsyncWithHttpInfo
     *
     * Get my orders
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyOrdersAsyncWithHttpInfo($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrdersResponse';
        $request = $this->getMyOrdersRequest($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyOrders'
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyOrdersRequest($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyParties
     *
     * Get my parties
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartyResponseArray
     */
    public function getMyParties($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyPartiesWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyPartiesWithHttpInfo
     *
     * Get my parties
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartyResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyPartiesWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponseArray';
        $request = $this->getMyPartiesRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartyResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyPartiesAsync
     *
     * Get my parties
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyPartiesAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyPartiesAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyPartiesAsyncWithHttpInfo
     *
     * Get my parties
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyPartiesAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponseArray';
        $request = $this->getMyPartiesRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyParties'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyPartiesRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/parties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyPartnerData
     *
     * Get my partner-data
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnersDataResponse
     */
    public function getMyPartnerData($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyPartnerDataWithHttpInfo($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyPartnerDataWithHttpInfo
     *
     * Get my partner-data
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnersDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyPartnerDataWithHttpInfo($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnersDataResponse';
        $request = $this->getMyPartnerDataRequest($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnersDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyPartnerDataAsync
     *
     * Get my partner-data
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyPartnerDataAsync($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyPartnerDataAsyncWithHttpInfo($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyPartnerDataAsyncWithHttpInfo
     *
     * Get my partner-data
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyPartnerDataAsyncWithHttpInfo($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnersDataResponse';
        $request = $this->getMyPartnerDataRequest($continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyPartnerData'
     *
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyPartnerDataRequest($continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/partnerdata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyProfile
     *
     * Get my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPersonResponse
     */
    public function getMyProfile($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyProfileWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyProfileWithHttpInfo
     *
     * Get my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPersonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyProfileWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPersonResponse';
        $request = $this->getMyProfileRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPersonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyProfileAsync
     *
     * Get my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyProfileAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyProfileAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyProfileAsyncWithHttpInfo
     *
     * Get my profile
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyProfileAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPersonResponse';
        $request = $this->getMyProfileRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyProfile'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyProfileRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyStays
     *
     * Get my stays
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponseArray
     */
    public function getMyStays($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyStaysWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyStaysWithHttpInfo
     *
     * Get my stays
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyStaysWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponseArray';
        $request = $this->getMyStaysRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyStaysAsync
     *
     * Get my stays
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyStaysAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyStaysAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyStaysAsyncWithHttpInfo
     *
     * Get my stays
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyStaysAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponseArray';
        $request = $this->getMyStaysRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyStays'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyStaysRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/stays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyTickets
     *
     * Get my tickets
     *
     * @param  string $scope Scope of the tickets (Default: currentAndFuture). Valid values: currentAndFuture, current, past, all (optional)
     * @param  string $order_number To get only ticket related to order (optional)
     * @param  int $additional_type Format - int32. Filter by the additional type property (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTicketsResponse
     */
    public function getMyTickets($scope = null, $order_number = null, $additional_type = null, $continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getMyTicketsWithHttpInfo($scope, $order_number, $additional_type, $continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getMyTicketsWithHttpInfo
     *
     * Get my tickets
     *
     * @param  string $scope Scope of the tickets (Default: currentAndFuture). Valid values: currentAndFuture, current, past, all (optional)
     * @param  string $order_number To get only ticket related to order (optional)
     * @param  int $additional_type Format - int32. Filter by the additional type property (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTicketsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyTicketsWithHttpInfo($scope = null, $order_number = null, $additional_type = null, $continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsResponse';
        $request = $this->getMyTicketsRequest($scope, $order_number, $additional_type, $continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTicketsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyTicketsAsync
     *
     * Get my tickets
     *
     * @param  string $scope Scope of the tickets (Default: currentAndFuture). Valid values: currentAndFuture, current, past, all (optional)
     * @param  string $order_number To get only ticket related to order (optional)
     * @param  int $additional_type Format - int32. Filter by the additional type property (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTicketsAsync($scope = null, $order_number = null, $additional_type = null, $continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getMyTicketsAsyncWithHttpInfo($scope, $order_number, $additional_type, $continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyTicketsAsyncWithHttpInfo
     *
     * Get my tickets
     *
     * @param  string $scope Scope of the tickets (Default: currentAndFuture). Valid values: currentAndFuture, current, past, all (optional)
     * @param  string $order_number To get only ticket related to order (optional)
     * @param  int $additional_type Format - int32. Filter by the additional type property (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTicketsAsyncWithHttpInfo($scope = null, $order_number = null, $additional_type = null, $continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsResponse';
        $request = $this->getMyTicketsRequest($scope, $order_number, $additional_type, $continuation_token, $top, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyTickets'
     *
     * @param  string $scope Scope of the tickets (Default: currentAndFuture). Valid values: currentAndFuture, current, past, all (optional)
     * @param  string $order_number To get only ticket related to order (optional)
     * @param  int $additional_type Format - int32. Filter by the additional type property (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyTicketsRequest($scope = null, $order_number = null, $additional_type = null, $continuation_token = null, $top = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/tickets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope, null);
        }
        // query params
        if ($order_number !== null) {
            $queryParams['orderNumber'] = ObjectSerializer::toQueryValue($order_number, null);
        }
        // query params
        if ($additional_type !== null) {
            $queryParams['additionalType'] = ObjectSerializer::toQueryValue($additional_type, 'int32');
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrder
     *
     * Get order
     *
     * @param  string $id Id of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsOrderB2CResponse
     */
    public function getOrder($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getOrderWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getOrderWithHttpInfo
     *
     * Get order
     *
     * @param  string $id Id of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsOrderB2CResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrderB2CResponse';
        $request = $this->getOrderRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsOrderB2CResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderAsync
     *
     * Get order
     *
     * @param  string $id Id of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getOrderAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderAsyncWithHttpInfo
     *
     * Get order
     *
     * @param  string $id Id of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsOrderB2CResponse';
        $request = $this->getOrderRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrder'
     *
     * @param  string $id Id of the order. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOrder'
            );
        }

        $resourcePath = '/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPartnerdata
     *
     * Get partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnerDataResponse
     */
    public function getPartnerdata($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getPartnerdataWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getPartnerdataWithHttpInfo
     *
     * Get partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnerDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPartnerdataWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->getPartnerdataRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnerDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPartnerdataAsync
     *
     * Get partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartnerdataAsync($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getPartnerdataAsyncWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPartnerdataAsyncWithHttpInfo
     *
     * Get partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartnerdataAsyncWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->getPartnerdataRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPartnerdata'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPartnerdataRequest($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPartnerdata'
            );
        }

        $resourcePath = '/partnerdata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParty
     *
     * Get party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartyResponse
     */
    public function getParty($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getPartyWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getPartyWithHttpInfo
     *
     * Get party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPartyWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->getPartyRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPartyAsync
     *
     * Get party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartyAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getPartyAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPartyAsyncWithHttpInfo
     *
     * Get party
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartyAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->getPartyRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParty'
     *
     * @param  string $id Id of the party. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPartyRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getParty'
            );
        }

        $resourcePath = '/parties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfilePictureThumbnail
     *
     * Get profile picture thumbnail
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsMeProfileimageGet200TextPlainResponse
     */
    public function getProfilePictureThumbnail($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getProfilePictureThumbnailWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getProfilePictureThumbnailWithHttpInfo
     *
     * Get profile picture thumbnail
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsMeProfileimageGet200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfilePictureThumbnailWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMeProfileimageGet200TextPlainResponse';
        $request = $this->getProfilePictureThumbnailRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsMeProfileimageGet200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfilePictureThumbnailAsync
     *
     * Get profile picture thumbnail
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfilePictureThumbnailAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getProfilePictureThumbnailAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfilePictureThumbnailAsyncWithHttpInfo
     *
     * Get profile picture thumbnail
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfilePictureThumbnailAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsMeProfileimageGet200TextPlainResponse';
        $request = $this->getProfilePictureThumbnailRequest($ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfilePictureThumbnail'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProfilePictureThumbnailRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/me/profileimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatus
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getStatus($ocp_apim_subscription_key = null)
    {
        $this->getStatusWithHttpInfo($ocp_apim_subscription_key);
    }

    /**
     * Operation getStatusWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAsync
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsync($ocp_apim_subscription_key = null)
    {
        return $this->getStatusAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAsyncWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsyncWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatus'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusRequest($ocp_apim_subscription_key = null)
    {

        $resourcePath = '/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusAbout
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStatusResponse
     */
    public function getStatusAbout($ocp_apim_subscription_key = null)
    {
        list($response) = $this->getStatusAboutWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation getStatusAboutWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusAboutWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAboutAsync
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsync($ocp_apim_subscription_key = null)
    {
        return $this->getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAboutAsyncWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusAbout'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusAboutRequest($ocp_apim_subscription_key = null)
    {

        $resourcePath = '/status/about';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStay
     *
     * Get stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponse
     */
    public function getStay($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getStayWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getStayWithHttpInfo
     *
     * Get stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStayWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->getStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStayAsync
     *
     * Get stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStayAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStayAsyncWithHttpInfo
     *
     * Get stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->getStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStay'
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStayRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getStay'
            );
        }

        $resourcePath = '/stays/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTicket
     *
     * Get ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTicketB2CResponse
     */
    public function getTicket($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getTicketWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getTicketWithHttpInfo
     *
     * Get ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTicketB2CResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTicketWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketB2CResponse';
        $request = $this->getTicketRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTicketB2CResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTicketAsync
     *
     * Get ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTicketAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getTicketAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTicketAsyncWithHttpInfo
     *
     * Get ticket
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTicketAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketB2CResponse';
        $request = $this->getTicketRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTicket'
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTicketRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTicket'
            );
        }

        $resourcePath = '/tickets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTicketBinary
     *
     * Get ticket binary
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTicketsIdBase64Get200TextPlainResponse
     */
    public function getTicketBinary($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->getTicketBinaryWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation getTicketBinaryWithHttpInfo
     *
     * Get ticket binary
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTicketsIdBase64Get200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTicketBinaryWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsIdBase64Get200TextPlainResponse';
        $request = $this->getTicketBinaryRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTicketsIdBase64Get200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTicketBinaryAsync
     *
     * Get ticket binary
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTicketBinaryAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->getTicketBinaryAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTicketBinaryAsyncWithHttpInfo
     *
     * Get ticket binary
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTicketBinaryAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTicketsIdBase64Get200TextPlainResponse';
        $request = $this->getTicketBinaryRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTicketBinary'
     *
     * @param  string $id Id of the ticket. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTicketBinaryRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTicketBinary'
            );
        }

        $resourcePath = '/tickets/{id}/base64';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getToken
     *
     * Get token
     *
     * @param  string $grant_type the type of the token request: guest, authorization_header or refresh_token (required)
     * @param  string $refresh_token The refresh token case of grant_type&#x3D;refresh_token (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTokenResponse
     */
    public function getToken($grant_type, $refresh_token = null, $max_refresh_lifetime = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->getTokenWithHttpInfo($grant_type, $refresh_token, $max_refresh_lifetime, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation getTokenWithHttpInfo
     *
     * Get token
     *
     * @param  string $grant_type the type of the token request: guest, authorization_header or refresh_token (required)
     * @param  string $refresh_token The refresh token case of grant_type&#x3D;refresh_token (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTokenWithHttpInfo($grant_type, $refresh_token = null, $max_refresh_lifetime = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTokenResponse';
        $request = $this->getTokenRequest($grant_type, $refresh_token, $max_refresh_lifetime, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTokenAsync
     *
     * Get token
     *
     * @param  string $grant_type the type of the token request: guest, authorization_header or refresh_token (required)
     * @param  string $refresh_token The refresh token case of grant_type&#x3D;refresh_token (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTokenAsync($grant_type, $refresh_token = null, $max_refresh_lifetime = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->getTokenAsyncWithHttpInfo($grant_type, $refresh_token, $max_refresh_lifetime, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTokenAsyncWithHttpInfo
     *
     * Get token
     *
     * @param  string $grant_type the type of the token request: guest, authorization_header or refresh_token (required)
     * @param  string $refresh_token The refresh token case of grant_type&#x3D;refresh_token (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTokenAsyncWithHttpInfo($grant_type, $refresh_token = null, $max_refresh_lifetime = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTokenResponse';
        $request = $this->getTokenRequest($grant_type, $refresh_token, $max_refresh_lifetime, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getToken'
     *
     * @param  string $grant_type the type of the token request: guest, authorization_header or refresh_token (required)
     * @param  string $refresh_token The refresh token case of grant_type&#x3D;refresh_token (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTokenRequest($grant_type, $refresh_token = null, $max_refresh_lifetime = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'grant_type' is set
        if ($grant_type === null || (is_array($grant_type) && count($grant_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $grant_type when calling getToken'
            );
        }

        $resourcePath = '/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($grant_type !== null) {
            $queryParams['grant_type'] = ObjectSerializer::toQueryValue($grant_type, null);
        }
        // query params
        if ($refresh_token !== null) {
            $queryParams['refresh_token'] = ObjectSerializer::toQueryValue($refresh_token, null);
        }
        // query params
        if ($max_refresh_lifetime !== null) {
            $queryParams['max_refresh_lifetime'] = ObjectSerializer::toQueryValue($max_refresh_lifetime, null);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importSharedProfileData
     *
     * Import shared profile data
     *
     * @param  string $sharing_identifier Profile Data share ID (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsProfileDataImportResponse
     */
    public function importSharedProfileData($sharing_identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->importSharedProfileDataWithHttpInfo($sharing_identifier, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation importSharedProfileDataWithHttpInfo
     *
     * Import shared profile data
     *
     * @param  string $sharing_identifier Profile Data share ID (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsProfileDataImportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importSharedProfileDataWithHttpInfo($sharing_identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileDataImportResponse';
        $request = $this->importSharedProfileDataRequest($sharing_identifier, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsProfileDataImportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importSharedProfileDataAsync
     *
     * Import shared profile data
     *
     * @param  string $sharing_identifier Profile Data share ID (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importSharedProfileDataAsync($sharing_identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->importSharedProfileDataAsyncWithHttpInfo($sharing_identifier, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importSharedProfileDataAsyncWithHttpInfo
     *
     * Import shared profile data
     *
     * @param  string $sharing_identifier Profile Data share ID (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importSharedProfileDataAsyncWithHttpInfo($sharing_identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileDataImportResponse';
        $request = $this->importSharedProfileDataRequest($sharing_identifier, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importSharedProfileData'
     *
     * @param  string $sharing_identifier Profile Data share ID (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importSharedProfileDataRequest($sharing_identifier, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'sharing_identifier' is set
        if ($sharing_identifier === null || (is_array($sharing_identifier) && count($sharing_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharing_identifier when calling importSharedProfileData'
            );
        }

        $resourcePath = '/import/{sharingIdentifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($sharing_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'sharingIdentifier' . '}',
                ObjectSerializer::toPathValue($sharing_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initializeStay
     *
     * Initialize stay
     *
     * @param  \ProfileService\Client\Model\DsStayRequest $body StayRequest containing the parameters to initialize the stay. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponse
     */
    public function initializeStay($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->initializeStayWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation initializeStayWithHttpInfo
     *
     * Initialize stay
     *
     * @param  \ProfileService\Client\Model\DsStayRequest $body StayRequest containing the parameters to initialize the stay. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function initializeStayWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->initializeStayRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initializeStayAsync
     *
     * Initialize stay
     *
     * @param  \ProfileService\Client\Model\DsStayRequest $body StayRequest containing the parameters to initialize the stay. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initializeStayAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->initializeStayAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initializeStayAsyncWithHttpInfo
     *
     * Initialize stay
     *
     * @param  \ProfileService\Client\Model\DsStayRequest $body StayRequest containing the parameters to initialize the stay. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initializeStayAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->initializeStayRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initializeStay'
     *
     * @param  \ProfileService\Client\Model\DsStayRequest $body StayRequest containing the parameters to initialize the stay. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function initializeStayRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/stays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation joinParty
     *
     * Join party
     *
     * @param  \ProfileService\Client\Model\DsJoinPartyRequest $body Join party request (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartiesJoinPut200ApplicationJsonResponse
     */
    public function joinParty($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->joinPartyWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation joinPartyWithHttpInfo
     *
     * Join party
     *
     * @param  \ProfileService\Client\Model\DsJoinPartyRequest $body Join party request (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartiesJoinPut200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function joinPartyWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesJoinPut200ApplicationJsonResponse';
        $request = $this->joinPartyRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartiesJoinPut200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation joinPartyAsync
     *
     * Join party
     *
     * @param  \ProfileService\Client\Model\DsJoinPartyRequest $body Join party request (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinPartyAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->joinPartyAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation joinPartyAsyncWithHttpInfo
     *
     * Join party
     *
     * @param  \ProfileService\Client\Model\DsJoinPartyRequest $body Join party request (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinPartyAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartiesJoinPut200ApplicationJsonResponse';
        $request = $this->joinPartyRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'joinParty'
     *
     * @param  \ProfileService\Client\Model\DsJoinPartyRequest $body Join party request (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function joinPartyRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/parties/join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAddresses
     *
     * ListAddresses
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsAddressResponseArray
     */
    public function listAddresses($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->listAddressesWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation listAddressesWithHttpInfo
     *
     * ListAddresses
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsAddressResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAddressesWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsAddressResponseArray';
        $request = $this->listAddressesRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsAddressResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAddressesAsync
     *
     * ListAddresses
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAddressesAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->listAddressesAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAddressesAsyncWithHttpInfo
     *
     * ListAddresses
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAddressesAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsAddressResponseArray';
        $request = $this->listAddressesRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAddresses'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAddressesRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTravelers
     *
     * ListTravelers
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTravelerResponseArray
     */
    public function listTravelers($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->listTravelersWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTravelersWithHttpInfo
     *
     * ListTravelers
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTravelerResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTravelersWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTravelerResponseArray';
        $request = $this->listTravelersRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTravelerResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTravelersAsync
     *
     * ListTravelers
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTravelersAsync($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->listTravelersAsyncWithHttpInfo($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTravelersAsyncWithHttpInfo
     *
     * ListTravelers
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTravelersAsyncWithHttpInfo($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTravelerResponseArray';
        $request = $this->listTravelersRequest($ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTravelers'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTravelersRequest($ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/travelers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pATCHPartnerdataObject
     *
     * PATCH partnerdata object
     *
     * @param  string $name Name of the partnerdata object (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnerDataResponse
     */
    public function pATCHPartnerdataObject($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->pATCHPartnerdataObjectWithHttpInfo($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation pATCHPartnerdataObjectWithHttpInfo
     *
     * PATCH partnerdata object
     *
     * @param  string $name Name of the partnerdata object (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnerDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pATCHPartnerdataObjectWithHttpInfo($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->pATCHPartnerdataObjectRequest($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnerDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pATCHPartnerdataObjectAsync
     *
     * PATCH partnerdata object
     *
     * @param  string $name Name of the partnerdata object (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pATCHPartnerdataObjectAsync($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->pATCHPartnerdataObjectAsyncWithHttpInfo($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pATCHPartnerdataObjectAsyncWithHttpInfo
     *
     * PATCH partnerdata object
     *
     * @param  string $name Name of the partnerdata object (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pATCHPartnerdataObjectAsyncWithHttpInfo($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->pATCHPartnerdataObjectRequest($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pATCHPartnerdataObject'
     *
     * @param  string $name Name of the partnerdata object (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pATCHPartnerdataObjectRequest($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling pATCHPartnerdataObject'
            );
        }

        $resourcePath = '/partnerdata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendAccountVerificationEmail
     *
     * Resend account verification email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resendAccountVerificationEmail($authorization, $ocp_apim_subscription_key = null)
    {
        $this->resendAccountVerificationEmailWithHttpInfo($authorization, $ocp_apim_subscription_key);
    }

    /**
     * Operation resendAccountVerificationEmailWithHttpInfo
     *
     * Resend account verification email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resendAccountVerificationEmailWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->resendAccountVerificationEmailRequest($authorization, $ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resendAccountVerificationEmailAsync
     *
     * Resend account verification email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendAccountVerificationEmailAsync($authorization, $ocp_apim_subscription_key = null)
    {
        return $this->resendAccountVerificationEmailAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resendAccountVerificationEmailAsyncWithHttpInfo
     *
     * Resend account verification email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendAccountVerificationEmailAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->resendAccountVerificationEmailRequest($authorization, $ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resendAccountVerificationEmail'
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resendAccountVerificationEmailRequest($authorization, $ocp_apim_subscription_key = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling resendAccountVerificationEmail'
            );
        }

        $resourcePath = '/me/verify/email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveConsentDissent
     *
     * Save consent/dissent
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body AcceptTermVersionRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsTokenResponse
     */
    public function saveConsentDissent($body = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $max_refresh_lifetime = null)
    {
        list($response) = $this->saveConsentDissentWithHttpInfo($body, $ocp_apim_subscription_key, $accept_timezone, $max_refresh_lifetime);
        return $response;
    }

    /**
     * Operation saveConsentDissentWithHttpInfo
     *
     * Save consent/dissent
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body AcceptTermVersionRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveConsentDissentWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $max_refresh_lifetime = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTokenResponse';
        $request = $this->saveConsentDissentRequest($body, $ocp_apim_subscription_key, $accept_timezone, $max_refresh_lifetime);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation saveConsentDissentAsync
     *
     * Save consent/dissent
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body AcceptTermVersionRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveConsentDissentAsync($body = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $max_refresh_lifetime = null)
    {
        return $this->saveConsentDissentAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $accept_timezone, $max_refresh_lifetime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveConsentDissentAsyncWithHttpInfo
     *
     * Save consent/dissent
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body AcceptTermVersionRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveConsentDissentAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $max_refresh_lifetime = null)
    {
        $returnType = '\ProfileService\Client\Model\DsTokenResponse';
        $request = $this->saveConsentDissentRequest($body, $ocp_apim_subscription_key, $accept_timezone, $max_refresh_lifetime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveConsentDissent'
     *
     * @param  \ProfileService\Client\Model\DsAcceptTermVersionRequest $body AcceptTermVersionRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     * @param  string $max_refresh_lifetime maximal refresh token lifetime requested by the client in days (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveConsentDissentRequest($body = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $max_refresh_lifetime = null)
    {

        $resourcePath = '/anonymous/terms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_refresh_lifetime !== null) {
            $queryParams['max_refresh_lifetime'] = ObjectSerializer::toQueryValue($max_refresh_lifetime, null);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendOtp
     *
     * Send Otp
     *
     * @param  \ProfileService\Client\Model\DsSendOtpRequest $body body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsSendOtpResponse
     */
    public function sendOtp($body = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        list($response) = $this->sendOtpWithHttpInfo($body, $ocp_apim_subscription_key, $accept_language);
        return $response;
    }

    /**
     * Operation sendOtpWithHttpInfo
     *
     * Send Otp
     *
     * @param  \ProfileService\Client\Model\DsSendOtpRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsSendOtpResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendOtpWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\ProfileService\Client\Model\DsSendOtpResponse';
        $request = $this->sendOtpRequest($body, $ocp_apim_subscription_key, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsSendOtpResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsSendOtpResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendOtpAsync
     *
     * Send Otp
     *
     * @param  \ProfileService\Client\Model\DsSendOtpRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendOtpAsync($body = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        return $this->sendOtpAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendOtpAsyncWithHttpInfo
     *
     * Send Otp
     *
     * @param  \ProfileService\Client\Model\DsSendOtpRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendOtpAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\ProfileService\Client\Model\DsSendOtpResponse';
        $request = $this->sendOtpRequest($body, $ocp_apim_subscription_key, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendOtp'
     *
     * @param  \ProfileService\Client\Model\DsSendOtpRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendOtpRequest($body = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {

        $resourcePath = '/auth/otp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sharePartnerdataObject
     *
     * Share partnerdata object
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsProfileDataShareResponse
     */
    public function sharePartnerdataObject($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->sharePartnerdataObjectWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation sharePartnerdataObjectWithHttpInfo
     *
     * Share partnerdata object
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsProfileDataShareResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sharePartnerdataObjectWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileDataShareResponse';
        $request = $this->sharePartnerdataObjectRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsProfileDataShareResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sharePartnerdataObjectAsync
     *
     * Share partnerdata object
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sharePartnerdataObjectAsync($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->sharePartnerdataObjectAsyncWithHttpInfo($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sharePartnerdataObjectAsyncWithHttpInfo
     *
     * Share partnerdata object
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sharePartnerdataObjectAsyncWithHttpInfo($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileDataShareResponse';
        $request = $this->sharePartnerdataObjectRequest($name, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sharePartnerdataObject'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sharePartnerdataObjectRequest($name, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling sharePartnerdataObject'
            );
        }

        $resourcePath = '/partnerdata/{name}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCard
     *
     * Update card
     *
     * @param  string $id Id of the card. (required)
     * @param  \ProfileService\Client\Model\DsCardRequest $body CardRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsCardResponse
     */
    public function updateCard($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->updateCardWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation updateCardWithHttpInfo
     *
     * Update card
     *
     * @param  string $id Id of the card. (required)
     * @param  \ProfileService\Client\Model\DsCardRequest $body CardRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsCardResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCardWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->updateCardRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsCardResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCardAsync
     *
     * Update card
     *
     * @param  string $id Id of the card. (required)
     * @param  \ProfileService\Client\Model\DsCardRequest $body CardRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCardAsync($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->updateCardAsyncWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCardAsyncWithHttpInfo
     *
     * Update card
     *
     * @param  string $id Id of the card. (required)
     * @param  \ProfileService\Client\Model\DsCardRequest $body CardRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCardAsyncWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsCardResponse';
        $request = $this->updateCardRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCard'
     *
     * @param  string $id Id of the card. (required)
     * @param  \ProfileService\Client\Model\DsCardRequest $body CardRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCardRequest($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateCard'
            );
        }

        $resourcePath = '/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomerInStay
     *
     * Update customer in stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponse
     */
    public function updateCustomerInStay($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->updateCustomerInStayWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation updateCustomerInStayWithHttpInfo
     *
     * Update customer in stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomerInStayWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->updateCustomerInStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCustomerInStayAsync
     *
     * Update customer in stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomerInStayAsync($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->updateCustomerInStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomerInStayAsyncWithHttpInfo
     *
     * Update customer in stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomerInStayAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->updateCustomerInStayRequest($id, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomerInStay'
     *
     * @param  string $id Id of the stay. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCustomerInStayRequest($id, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateCustomerInStay'
            );
        }

        $resourcePath = '/stays/{id}/customer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMyProfile
     *
     * Update my profile
     *
     * @param  \ProfileService\Client\Model\DsPersonRequest $body PersonRequest properties to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPersonResponse
     */
    public function updateMyProfile($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->updateMyProfileWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation updateMyProfileWithHttpInfo
     *
     * Update my profile
     *
     * @param  \ProfileService\Client\Model\DsPersonRequest $body PersonRequest properties to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPersonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMyProfileWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPersonResponse';
        $request = $this->updateMyProfileRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPersonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateMyProfileAsync
     *
     * Update my profile
     *
     * @param  \ProfileService\Client\Model\DsPersonRequest $body PersonRequest properties to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMyProfileAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->updateMyProfileAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMyProfileAsyncWithHttpInfo
     *
     * Update my profile
     *
     * @param  \ProfileService\Client\Model\DsPersonRequest $body PersonRequest properties to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMyProfileAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPersonResponse';
        $request = $this->updateMyProfileRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMyProfile'
     *
     * @param  \ProfileService\Client\Model\DsPersonRequest $body PersonRequest properties to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateMyProfileRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {

        $resourcePath = '/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrCreatePartnerdata
     *
     * Update or create partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartnerDataResponse
     */
    public function updateOrCreatePartnerdata($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->updateOrCreatePartnerdataWithHttpInfo($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation updateOrCreatePartnerdataWithHttpInfo
     *
     * Update or create partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartnerDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrCreatePartnerdataWithHttpInfo($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->updateOrCreatePartnerdataRequest($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartnerDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrCreatePartnerdataAsync
     *
     * Update or create partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrCreatePartnerdataAsync($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->updateOrCreatePartnerdataAsyncWithHttpInfo($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrCreatePartnerdataAsyncWithHttpInfo
     *
     * Update or create partnerdata
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrCreatePartnerdataAsyncWithHttpInfo($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartnerDataResponse';
        $request = $this->updateOrCreatePartnerdataRequest($name, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrCreatePartnerdata'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  \ProfileService\Client\Model\DsPartnerDataUpdateRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateOrCreatePartnerdataRequest($name, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateOrCreatePartnerdata'
            );
        }

        $resourcePath = '/partnerdata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePartnerdataProperty
     *
     * Update partnerdata property
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $property_id Name of the propertyId (required)
     * @param  \ProfileService\Client\Model\DsPropertyValueRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updatePartnerdataProperty($name, $property_id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $this->updatePartnerdataPropertyWithHttpInfo($name, $property_id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
    }

    /**
     * Operation updatePartnerdataPropertyWithHttpInfo
     *
     * Update partnerdata property
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $property_id Name of the propertyId (required)
     * @param  \ProfileService\Client\Model\DsPropertyValueRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePartnerdataPropertyWithHttpInfo($name, $property_id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '';
        $request = $this->updatePartnerdataPropertyRequest($name, $property_id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updatePartnerdataPropertyAsync
     *
     * Update partnerdata property
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $property_id Name of the propertyId (required)
     * @param  \ProfileService\Client\Model\DsPropertyValueRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePartnerdataPropertyAsync($name, $property_id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->updatePartnerdataPropertyAsyncWithHttpInfo($name, $property_id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePartnerdataPropertyAsyncWithHttpInfo
     *
     * Update partnerdata property
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $property_id Name of the propertyId (required)
     * @param  \ProfileService\Client\Model\DsPropertyValueRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePartnerdataPropertyAsyncWithHttpInfo($name, $property_id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '';
        $request = $this->updatePartnerdataPropertyRequest($name, $property_id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePartnerdataProperty'
     *
     * @param  string $name Name of the partnerdata. (required)
     * @param  string $property_id Name of the propertyId (required)
     * @param  \ProfileService\Client\Model\DsPropertyValueRequest $body PartnerDataRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePartnerdataPropertyRequest($name, $property_id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updatePartnerdataProperty'
            );
        }
        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling updatePartnerdataProperty'
            );
        }

        $resourcePath = '/partnerdata/{name}/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateParty
     *
     * Update party
     *
     * @param  string $id Id of the party. (required)
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsPartyResponse
     */
    public function updateParty($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        list($response) = $this->updatePartyWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);
        return $response;
    }

    /**
     * Operation updatePartyWithHttpInfo
     *
     * Update party
     *
     * @param  string $id Id of the party. (required)
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsPartyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePartyWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->updatePartyRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsPartyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePartyAsync
     *
     * Update party
     *
     * @param  string $id Id of the party. (required)
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePartyAsync($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        return $this->updatePartyAsyncWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePartyAsyncWithHttpInfo
     *
     * Update party
     *
     * @param  string $id Id of the party. (required)
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePartyAsyncWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsPartyResponse';
        $request = $this->updatePartyRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateParty'
     *
     * @param  string $id Id of the party. (required)
     * @param  \ProfileService\Client\Model\DsPartyRequest $body PartyRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePartyRequest($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateParty'
            );
        }

        $resourcePath = '/parties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStay
     *
     * Update stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  \ProfileService\Client\Model\DsStayUpdateRequest $body StayRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsStayResponse
     */
    public function updateStay($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->updateStayWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation updateStayWithHttpInfo
     *
     * Update stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  \ProfileService\Client\Model\DsStayUpdateRequest $body StayRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsStayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStayWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->updateStayRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsStayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateStayAsync
     *
     * Update stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  \ProfileService\Client\Model\DsStayUpdateRequest $body StayRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStayAsync($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->updateStayAsyncWithHttpInfo($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStayAsyncWithHttpInfo
     *
     * Update stay
     *
     * @param  string $id Id of the stay. (required)
     * @param  \ProfileService\Client\Model\DsStayUpdateRequest $body StayRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStayAsyncWithHttpInfo($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsStayResponse';
        $request = $this->updateStayRequest($id, $body, $ocp_apim_subscription_key, $authorization, $profile_token, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStay'
     *
     * @param  string $id Id of the stay. (required)
     * @param  \ProfileService\Client\Model\DsStayUpdateRequest $body StayRequest to update. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateStayRequest($id, $body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateStay'
            );
        }

        $resourcePath = '/stays/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadMedia
     *
     * Upload media
     *
     * @param  string $additional_type additional_type (optional)
     * @param  string $name name (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsProfileMediaBaseResponse
     */
    public function uploadMedia($additional_type = null, $name = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->uploadMediaWithHttpInfo($additional_type, $name, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation uploadMediaWithHttpInfo
     *
     * Upload media
     *
     * @param  string $additional_type (optional)
     * @param  string $name (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsProfileMediaBaseResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadMediaWithHttpInfo($additional_type = null, $name = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->uploadMediaRequest($additional_type, $name, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsProfileMediaBaseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadMediaAsync
     *
     * Upload media
     *
     * @param  string $additional_type (optional)
     * @param  string $name (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMediaAsync($additional_type = null, $name = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->uploadMediaAsyncWithHttpInfo($additional_type, $name, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadMediaAsyncWithHttpInfo
     *
     * Upload media
     *
     * @param  string $additional_type (optional)
     * @param  string $name (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMediaAsyncWithHttpInfo($additional_type = null, $name = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsProfileMediaBaseResponse';
        $request = $this->uploadMediaRequest($additional_type, $name, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadMedia'
     *
     * @param  string $additional_type (optional)
     * @param  string $name (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadMediaRequest($additional_type = null, $name = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // form params
        if ($additional_type !== null) {
            $formParams['additionalType'] = ObjectSerializer::toFormValue($additional_type);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateEmailAddress
     *
     * Validate email address
     *
     * @param  \ProfileService\Client\Model\DsValidateEmailRequest $body body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsValidateEmailResponse
     */
    public function validateEmailAddress($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        list($response) = $this->validateEmailAddressWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token);
        return $response;
    }

    /**
     * Operation validateEmailAddressWithHttpInfo
     *
     * Validate email address
     *
     * @param  \ProfileService\Client\Model\DsValidateEmailRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsValidateEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateEmailAddressWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsValidateEmailResponse';
        $request = $this->validateEmailAddressRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsValidateEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsValidateEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateEmailAddressAsync
     *
     * Validate email address
     *
     * @param  \ProfileService\Client\Model\DsValidateEmailRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateEmailAddressAsync($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        return $this->validateEmailAddressAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $authorization, $profile_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateEmailAddressAsyncWithHttpInfo
     *
     * Validate email address
     *
     * @param  \ProfileService\Client\Model\DsValidateEmailRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateEmailAddressAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {
        $returnType = '\ProfileService\Client\Model\DsValidateEmailResponse';
        $request = $this->validateEmailAddressRequest($body, $ocp_apim_subscription_key, $authorization, $profile_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateEmailAddress'
     *
     * @param  \ProfileService\Client\Model\DsValidateEmailRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function validateEmailAddressRequest($body = null, $ocp_apim_subscription_key = null, $authorization = null, $profile_token = null)
    {

        $resourcePath = '/email/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyAccountEmail
     *
     * Verify account email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function verifyAccountEmail($authorization, $ocp_apim_subscription_key = null)
    {
        $this->verifyAccountEmailWithHttpInfo($authorization, $ocp_apim_subscription_key);
    }

    /**
     * Operation verifyAccountEmailWithHttpInfo
     *
     * Verify account email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyAccountEmailWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->verifyAccountEmailRequest($authorization, $ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation verifyAccountEmailAsync
     *
     * Verify account email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyAccountEmailAsync($authorization, $ocp_apim_subscription_key = null)
    {
        return $this->verifyAccountEmailAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyAccountEmailAsyncWithHttpInfo
     *
     * Verify account email
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyAccountEmailAsyncWithHttpInfo($authorization, $ocp_apim_subscription_key = null)
    {
        $returnType = '';
        $request = $this->verifyAccountEmailRequest($authorization, $ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyAccountEmail'
     *
     * @param  string $authorization Authorization header to identify the B2C user profile. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyAccountEmailRequest($authorization, $ocp_apim_subscription_key = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling verifyAccountEmail'
            );
        }

        $resourcePath = '/me/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation writeBusinessTrailEntry
     *
     * Write business trail entry
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProfileService\Client\Model\DsBusinesstrailPost200ApplicationJsonResponse
     */
    public function writeBusinessTrailEntry($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        list($response) = $this->writeBusinessTrailEntryWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);
        return $response;
    }

    /**
     * Operation writeBusinessTrailEntryWithHttpInfo
     *
     * Write business trail entry
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \ProfileService\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProfileService\Client\Model\DsBusinesstrailPost200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function writeBusinessTrailEntryWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsBusinesstrailPost200ApplicationJsonResponse';
        $request = $this->writeBusinessTrailEntryRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProfileService\Client\Model\DsBusinesstrailPost200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation writeBusinessTrailEntryAsync
     *
     * Write business trail entry
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function writeBusinessTrailEntryAsync($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        return $this->writeBusinessTrailEntryAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation writeBusinessTrailEntryAsyncWithHttpInfo
     *
     * Write business trail entry
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function writeBusinessTrailEntryAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {
        $returnType = '\ProfileService\Client\Model\DsBusinesstrailPost200ApplicationJsonResponse';
        $request = $this->writeBusinessTrailEntryRequest($body, $ocp_apim_subscription_key, $profile_token, $authorization, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'writeBusinessTrailEntry'
     *
     * @param  \ProfileService\Client\Model\DsBusinessTrailRequest $body BusinessTrailRequest. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $profile_token Profile token to identify the guest user profile. (optional)
     * @param  string $authorization Authorization header to identify the B2C user profile. (optional)
     * @param  string $accept_timezone Time zone ID for response dates &amp; times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function writeBusinessTrailEntryRequest($body = null, $ocp_apim_subscription_key = null, $profile_token = null, $authorization = null, $accept_timezone = null)
    {

        $resourcePath = '/businesstrail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($profile_token !== null) {
            $headerParams['ProfileToken'] = ObjectSerializer::toHeaderValue($profile_token);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
